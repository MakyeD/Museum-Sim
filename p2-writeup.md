# Project 2 Writeup

My solution is deadlock/starvation free. While it does not necesarily pass every single test, these cases are due to guides entering and leaving at incorrect times rather than ther being deadlocks or starvation. In the cases where my code is successful, the semaphores are used in a manner where visitors/guides are never deadlocked. For example, in the while loop where my guides admit visitors, I used two semaphores, but the while terminates before any cases where starvation or deadlocking could occur. The while loop stops running once the amount of visitors that will enter the line and/or the museum has been reached so resources will not be over/underallocated. 

Another protective condition that prevents deadlocking is that if all tickets have been allocated/used, any new visitors will immediately leave. This avoid having them wait for tickets to be available and avoids deadlocking as a possibility altogether. My guide() method implements a waiting method that ensures all guides leave at the same time. I do this by initializing a semaphore as zero, then having the visitors check if all visitors have left, if not the semaphore will remain as zero, but if all visitors have left, the semaphore will loop for as many times as there are guides inside the musuem and increment the semamphore so that each guide will be able to call sem_wait once and then leave. By having the loop run only as many times as there visitors inside, I am eliminating the possibility of deadlocking or starvation when my guides want to leave. And since semaphore is incremented from 0 to whatever the number of guides is, there will never be a case where one guide is able to leave but the other isn't.